import os
import sys
import threading
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import ffmpeg
from funasr import AutoModel
from modelscope.utils.logger import get_logger

logger = get_logger()
BASE_DIR = os.path.dirname(os.path.abspath(sys.argv[0])) # 程序路径
os.environ["FUNASR_HOME"] = os.path.join(BASE_DIR, "models", "funasr") # funasr路径，'本地路径/models/funasr'
os.environ["HF_HOME"] = os.path.join(BASE_DIR, "models", "hf_cache") # hf_cache路径，'本地路径/models/hf_cache'
os.environ["MODELSCOPE_CACHE"] = os.path.join(BASE_DIR, "models", "modelscope") # modelscope路径，'本地路径/models/modelscope'

model = AutoModel(
    model="paraformer-zh", # 识别模型
    vad_model="fsmn-vad", # 断句模型
    disable_update=True, # 禁用自动更新
    vad_model_revision="v2.0.4",
    punc_model="ct-punc-c", # 标点模型
    punc_model_revision="v2.0.4",
)

# 三个时间格式转换函数
def seconds_to_srt_time(seconds):
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    ms = int(round((seconds - int(seconds)) * 1000))
    return f"{hours:02}:{minutes:02}:{secs:02},{ms:03}"

def seconds_to_vtt_time(seconds):
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    ms = int(round((seconds - int(seconds)) * 1000))
    return f"{hours:02}:{minutes:02}:{secs:02}.{ms:03}"

def seconds_to_ass_time(seconds):
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    cs = int(round((seconds - int(seconds)) * 100))
    return f"{hours}:{minutes:02}:{secs:02}.{cs:02}"

# 获取音频时长
def get_audio_duration(filepath):
    try:
        probe = ffmpeg.probe(filepath)
        duration = float(probe['format']['duration'])
        return duration
    except Exception as e:
        logger.warning(f"无法获取音频时长: {e}")
        return None

# 四个保存字幕格式函数
def save_as_srt(sentences, path, max_duration=None):
    with open(path, "w", encoding="utf-8") as f:
        for i, s in enumerate(sentences, 1):
            start = s["start"] / 1000
            end = s["end"] / 1000
            if end < start: # 强制避免结束时间早于开始时间
                end = start + 0.001
            if max_duration: # 限制字幕时间不超过音频长度
                if start > max_duration:
                    start = max_duration
                if end > max_duration:
                    end = max_duration
            start_str = seconds_to_srt_time(start)
            end_str = seconds_to_srt_time(end)
            text = s["text"].rstrip("，,.。.") # 去除句末的标点
            f.write(f"{i}\n{start_str} --> {end_str}\n{text}\n\n")

def save_as_vtt(sentences, path, max_duration=None):
    with open(path, "w", encoding="utf-8") as f:
        f.write("WEBVTT\n\n")
        for i, s in enumerate(sentences, 1):
            start = s["start"] / 1000
            end = s["end"] / 1000
            if end < start: # 强制避免结束时间早于开始时间
                end = start + 0.001
            if max_duration: # 限制字幕时间不超过音频长度
                if start > max_duration:
                    start = max_duration
                if end > max_duration:
                    end = max_duration
            start_str = seconds_to_vtt_time(start)
            end_str = seconds_to_vtt_time(end)
            text = s["text"].rstrip("，,.。.") # 去除句末的标点
            f.write(f"{i}\n{start_str} --> {end_str}\n{text}\n\n")

def save_as_ass(sentences, path, max_duration=None):
    header = """[Script Info]
    Title: Generated by FunASR
    ScriptType: v4.00+
    Collisions: Normal
    PlayResX: 384
    PlayResY: 288
    Timer: 100.0000

    [V4+ Styles]
    Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
    Style: Default,微软雅黑,20,&H00FFFFFF,&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,1.5,0,2,10,10,10,1

    [Events]
    Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
    """
    with open(path, "w", encoding="utf-8") as f:
        f.write(header)
        for s in sentences:
            start = s["start"] / 1000
            end = s["end"] / 1000
            if end < start: # 强制避免结束时间早于开始时间
                end = start + 0.001
            if max_duration: # 限制字幕时间不超过音频长度
                if start > max_duration:
                    start = max_duration
                if end > max_duration:
                    end = max_duration
            start_str = seconds_to_ass_time(start)
            end_str = seconds_to_ass_time(end)
            text = s["text"].rstrip("，,.。.") # 去除句末的标点
            line = f"Dialogue: 0,{start_str},{end_str},Default,,0,0,0,,{text}\n"
            f.write(line)

def save_as_txt(sentences, path):
    with open(path, "w", encoding="utf-8") as f:
        for s in sentences:
            text = s["text"].rstrip("，,.。.") # 去除句末的标点
            f.write(text + "\n")

# tkinter界面
class ASRApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("语音识别 + 多格式字幕生成工具")
        self.geometry("600x550")

        self.file_path = None
        self.output_dir = None

        # UI组件
        tk.Label(self, text="选择音频文件:").pack(pady=5)
        tk.Button(self, text="选择文件", command=self.select_file).pack()
        self.label_file = tk.Label(self, text="未选择文件", fg="blue")
        self.label_file.pack()

        tk.Label(self, text="选择字幕输出目录（可选）:").pack(pady=5)
        tk.Button(self, text="选择目录", command=self.select_output_dir).pack()
        self.label_output = tk.Label(self, text="未设置，默认音频目录", fg="blue")
        self.label_output.pack()

        tk.Label(self, text="选择输出字幕格式:").pack(pady=5)
        self.format_var = tk.StringVar(value="srt")
        formats = ["srt", "vtt", "ass", "txt"]
        self.format_menu = ttk.Combobox(self, textvariable=self.format_var, values=formats, state="readonly")
        self.format_menu.pack()

        self.btn_start = tk.Button(self, text="开始识别并生成字幕", command=self.start_recognition)
        self.btn_start.pack(pady=10)

        self.progress = ttk.Progressbar(self, orient="horizontal", length=400, mode="determinate")
        self.progress.pack(pady=10)

        tk.Label(self, text="识别结果:").pack()
        self.text_result = tk.Text(self, height=15, wrap="word")
        self.text_result.pack(fill="both", expand=True, padx=10, pady=5)

    def select_file(self): # 选择音频
        path = filedialog.askopenfilename(title="选择音频文件", filetypes=[("音频文件", "*.wav *.mp3 *.pcm"), ("所有文件", "*.*")])
        if path:
            self.file_path = path
            self.label_file.config(text=path)
            self.text_result.delete(1.0, tk.END)

    def select_output_dir(self): # 选择输出路径
        dir_ = filedialog.askdirectory(title="选择输出目录")
        if dir_:
            self.output_dir = dir_
            self.label_output.config(text=dir_)
        else:
            self.output_dir = None
            self.label_output.config(text="未设置，默认音频目录")

    def start_recognition(self): # 开始识别
        if not self.file_path:
            messagebox.showwarning("提示", "请先选择音频文件！")
            return

        self.btn_start.config(state="disabled")
        self.progress["value"] = 0
        self.text_result.delete(1.0, tk.END)
        self.text_result.insert(tk.END, "开始识别，请稍候...\n")

        # 用线程执行识别，避免阻塞界面
        threading.Thread(target=self.run_recognition, daemon=True).start()

    def run_recognition(self): # 识别
        try:
            param_dict = {"sentence_timestamp": True, "batch_size_s": 300}
            audio_bytes, _ = (
                ffmpeg.input(self.file_path, threads=0)
                .output("-", format="s16le", acodec="pcm_s16le", ac=1, ar=16000)
                .run(cmd=["ffmpeg", "-nostdin"], capture_stdout=True, capture_stderr=True)
            )
            self.set_progress(30)

            rec_results = model.generate(input=audio_bytes, is_final=True, **param_dict)
            self.set_progress(65)

            if len(rec_results) == 0:
                self.show_result([], None)
                return

            rec_result = rec_results[0]
            filename = os.path.splitext(os.path.basename(self.file_path))[0]
            save_dir = self.output_dir if self.output_dir else os.path.dirname(self.file_path)
            ext = self.format_var.get().lower()
            save_path = os.path.join(save_dir, f"{filename}.{ext}")

            audio_duration = get_audio_duration(self.file_path)

            if ext == "srt":
                save_as_srt(rec_result["sentence_info"], save_path, max_duration=audio_duration)
            elif ext == "vtt":
                save_as_vtt(rec_result["sentence_info"], save_path, max_duration=audio_duration)
            elif ext == "ass":
                save_as_ass(rec_result["sentence_info"], save_path, max_duration=audio_duration)
            elif ext == "txt":
                save_as_txt(rec_result["sentence_info"], save_path)
            else:
                self.show_result([], None)
                return

            self.set_progress(100)
            self.show_result(rec_result["sentence_info"], save_path)
        except Exception as e:
            logger.error(f"识别失败: {e}")
            self.show_result([], None)
        finally:
            self.btn_start.config(state="normal")

    def set_progress(self, value): # 进度条
        self.progress["value"] = value

    def show_result(self, sentences, save_path): # 显示结果
        if not sentences:
            self.text_result.insert(tk.END, "识别失败或结果为空。\n")
            self.set_progress(0)
            messagebox.showerror("错误", "识别失败或结果为空。")
            return

        self.text_result.insert(tk.END, f"字幕文件已保存到: {save_path}\n\n")
        self.text_result.insert(tk.END, "字幕内容预览:\n")
        try:
            with open(save_path, "r", encoding="utf-8") as f:
                content = f.read()
                self.text_result.insert(tk.END, content)
        except Exception as e:
            self.text_result.insert(tk.END, f"无法读取字幕文件内容: {e}\n")

if __name__ == "__main__":
    app = ASRApp()
    app.mainloop()
